电话面汇总
1.python 常见的数据类型  int string  dict list  tuple

2.上面常见的数据类型有哪些是可变的，哪些是不可变的，为什么？
可变/不可变类型,指的是：内存id不变，type也不变的前提下，value是否是可变的。tuple的每个元素，指向永远不变

3. ==和is 的区别
is比较的是id 而‘==’比较的是值

4.python 里面的类的声明，继承，需要注意的地方 子类继承，子类初始化，子类的重写
（1）子类的初始化的时候,用传统的调用直接用父类调用__init__()
（2）新式类(就是父类继承object类),子类的初始化的时候
（3）除了直接用父类调用__init__()，还可以用super这个关键字

5. 进程  线程 协程的区别
进程就是一个程序在一个数据集上的一次动态执行过程。线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同 一内存空间，
当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥
有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。

6.线程通信
共享变量  queue

7.进程通信
queue  pipe实现进程间通信

8.协程的使用场景
爬取数据

9.http请求过程
（1）浏览器根据域名解析IP地址
    浏览器缓存：首先搜索浏览器自身的DNS缓存,看自身的缓存中是否是有域名对应的条目，而且没有过期，如果有且没有过期则解析到此结束。
    系统缓存：如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索解析到此结束。
    路由器缓存：如果系统缓存也没有找到，则会向路由器发送查询请求。
    ISP（互联网服务提供商） DNS缓存：如果在路由缓存也没找到，最后要查的就是ISP缓存DNS的服务器。
 (2)浏览器与WEB服务器建立一个TCP连接
    TCP的3次握手。
 (3)浏览器给WEB服务器发送一个HTTP请求
    一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。
 (4)服务器端响应HTTP请求，浏览器得到HTML代码
    HTTP响应报文由状态行（status line）、相应头部（headers）、空行（blank line）和响应数据（response body）4个部分组成。
 (5)浏览器解析HTML代码，并请求HTML代码中的资源
    浏览器拿到HTML文件后，开始解析HTML代码，遇到静态资源时，就向服务器端去请求下载。
 (6)关闭TCP连接，浏览器对页面进行渲染呈现给用户
    浏览器利用自己内部的工作机制，把请求到的静态资源和HTML代码进行渲染，呈现给用户。
    最后一步浏览器是如何对页面进行渲染的？
    a）解析html文件构成 DOM树，b）解析CSS文件构成渲染树，  c）边解析，边渲染 ，
    d）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载

10.常见的设计模式
(1) 开闭原则
开闭原则的含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。
软件实体包括以下几个部分：
项目或软件产品中按照一定的逻辑规则划分的模块
抽象和类方法
(2) 迪米特法则
个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的public方法，我就调用这么多，其他的一概不关心。
(3)接口隔离原则
建立单一接口，不要建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。
(4)里氏替换原则
通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。
(5)单一职责原则
应该有且仅有一个原因引起类的变更。
(6)依赖倒置原则
模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的；
接口或抽象类不依赖于实现类；
实现类依赖接口或抽象类。

11.mysql 里面的锁的类型
表锁和行锁


12.常见的算法，简单说一下某一个算法的原理
（1）.快速排序
    通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，
    整个排序过程可以递归进行，以此达到整个数据变成有序序列
    快速排序算法通过多次比较和交换来实现排序，其排序流程如下： 
        (1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 [2] 
        (2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 [2] 
        (3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 [2] 
        (4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。 [2] 
(2).选择排序
(3).冒泡排序
(4).二分查找
首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，
如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

13.tcp 的三次握手
第一次握手是在建立连接，客户端发送连接请求报文段，把标有SYN的数据包发给服务器端即为接收端。
第二次握手是服务器端即接收端收到客户端的SYN的报文段，同时发送标有SYN/ACK的数据包。
第三次握手是客户端收到服务器端的SYN/ACK的数据包后，向服务器端发送标有ACK的数据包。

14.四次挥手
第一次挥手
客户端设置seq和 ACK ,向服务器发送一个 FIN=1报文段。此时，（第一次挥手，FIN=1，seq=u）客户端进入 FIN_WAIT 状态，表示客户端没有数据要发送给服务端了。
第二次挥手
服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。
第三次挥手
服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。
第四次挥手
客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。
