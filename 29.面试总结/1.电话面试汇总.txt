电话面汇总
1.python 常见的数据类型  int string  dict list  tuple

2.上面常见的数据类型有哪些是可变的，哪些是不可变的，为什么？
可变/不可变类型,指的是：内存id不变，type也不变的前提下，value是否是可变的。tuple的每个元素，指向永远不变

3. ==和is 的区别
is比较的是id 而‘==’比较的是值

4.python 里面的类的声明，继承，需要注意的地方 子类继承，子类初始化，子类的重写
 在Python 2.2之前只有经典类，到Python2.7还会兼容经典类，Python3.x以后只使用新式类，Python之前版本也会兼容新式类
Python 2.2 及其之前类没有基类，Python新式类需要显式继承自object，即使不显式继承也会默认继承自object
经典类在类多重继承的时候是采用从左到右深度优先原则匹配方法的.而新式类是采用C3算法
经典类没有MRO和instance.mro()调用的
（1）子类的初始化的时候,用传统的调用直接用父类调用__init__()
（2）新式类(就是父类继承object类),子类的初始化的时候
（3）除了直接用父类调用__init__()，还可以用super这个关键字

5. 进程  线程 协程的区别
进程就是一个程序在一个数据集上的一次动态执行过程。线程是属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同 一内存空间，
当进程退出时该进程所产生的线程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本上不拥
有系统资源，只拥有一点在运行中必不可少的信息(如程序计数器、一组寄存器和栈)。

6.线程通信
共享变量  queue

7.进程通信
queue  pipe实现进程间通信

8.协程的使用场景(并发量大)
爬取数据
async 用来声明一个函数为异步函数，异步函数的特点是能在函数执行过程中挂起，去执行其他异步函数，等到挂起条件（假设挂起条件是sleep(5)）消失后，也就是5秒到了再回来执行。
await 用来用来声明程序挂起，比如异步程序执行到某一步时需要等待的时间很长，就将此挂起，去执行其他的异步程序。
await 后面只能跟异步程序或有__await__属性的对象，因为异步程序与一般程序不同。
假设有两个异步函数async a，async b，a中的某一步有await，当程序碰到关键字await b()后，异步程序挂起后去执行另一个异步b程序，
就是从函数内部跳出去执行其他函数，当挂起条件消失后，不管b是否执行完，要马上从b程序中跳出来，回到原程序执行原来的操作。
如果await后面跟的b函数不是异步函数，那么操作就只能等b执行完再返回，无法在b执行的过程中返回。
如果要在b执行完才返回，也就不需要用await关键字了，直接调用b函数就行。所以这就需要await后面跟的是异步函数了。
在一个异步函数中，可以不止一次挂起，也就是可以用多个await。

9.http请求过程
（1）浏览器根据域名解析IP地址
    浏览器缓存：首先搜索浏览器自身的DNS缓存,看自身的缓存中是否是有域名对应的条目，而且没有过期，如果有且没有过期则解析到此结束。
    系统缓存：如果浏览器自身的缓存里面没有找到对应的条目，那么浏览器会搜索操作系统自身的DNS缓存，如果找到且没有过期则停止搜索解析到此结束。
    路由器缓存：如果系统缓存也没有找到，则会向路由器发送查询请求。
    ISP（互联网服务提供商） DNS缓存：如果在路由缓存也没找到，最后要查的就是ISP缓存DNS的服务器。
 (2)浏览器与WEB服务器建立一个TCP连接
    TCP的3次握手。
 (3)浏览器给WEB服务器发送一个HTTP请求
    一个HTTP请求报文由请求行（request line）、请求头部（headers）、空行（blank line）和请求数据（request body）4个部分组成。
 (4)服务器端响应HTTP请求，浏览器得到HTML代码
    HTTP响应报文由状态行（status line）、相应头部（headers）、空行（blank line）和响应数据（response body）4个部分组成。
 (5)浏览器解析HTML代码，并请求HTML代码中的资源
    浏览器拿到HTML文件后，开始解析HTML代码，遇到静态资源时，就向服务器端去请求下载。
 (6)关闭TCP连接，浏览器对页面进行渲染呈现给用户
    浏览器利用自己内部的工作机制，把请求到的静态资源和HTML代码进行渲染，呈现给用户。
    最后一步浏览器是如何对页面进行渲染的？
    a）解析html文件构成 DOM树，b）解析CSS文件构成渲染树，  c）边解析，边渲染 ，
    d）JS 单线程运行，JS有可能修改DOM结构，意味着JS执行完成前，后续所有资源的下载是没有必要的，所以JS是单线程，会阻塞后续资源下载

10.常见的设计模式
(1) 开闭原则
开闭原则的含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有代码来实现变化。
软件实体包括以下几个部分：
项目或软件产品中按照一定的逻辑规则划分的模块
抽象和类方法
(2) 迪米特法则
个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的public方法，我就调用这么多，其他的一概不关心。
(3)接口隔离原则
建立单一接口，不要建立臃肿庞大的接口。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。
(4)里氏替换原则
通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。
(5)单一职责原则
应该有且仅有一个原因引起类的变更。
(6)依赖倒置原则
模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的；
接口或抽象类不依赖于实现类；
实现类依赖接口或抽象类。

11.mysql 里面的锁的类型
表锁和行锁


12.常见的算法，简单说一下某一个算法的原理
（1）.快速排序
    通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，
    整个排序过程可以递归进行，以此达到整个数据变成有序序列
    快速排序算法通过多次比较和交换来实现排序，其排序流程如下： 
        (1)首先设定一个分界值，通过该分界值将数组分成左右两部分。 [2] 
        (2)将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。 [2] 
        (3)然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。 [2] 
        (4)重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。 [2] 
(2).选择排序
(3).冒泡排序
(4).二分查找
首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，
如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。

13.tcp 的三次握手
第一次握手是在建立连接，客户端发送连接请求报文段，把标有SYN的数据包发给服务器端即为接收端。
第二次握手是服务器端即接收端收到客户端的SYN的报文段，同时发送标有SYN/ACK的数据包。
第三次握手是客户端收到服务器端的SYN/ACK的数据包后，向服务器端发送标有ACK的数据包。

14.四次挥手
第一次挥手
客户端设置seq和 ACK ,向服务器发送一个 FIN=1报文段。此时，（第一次挥手，FIN=1，seq=u）客户端进入 FIN_WAIT 状态，表示客户端没有数据要发送给服务端了。
第二次挥手
服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。
第三次挥手
服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。
第四次挥手
客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。
此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。

15.uwisgi
异步使用

16. 猴子补丁
在运行时替换方法、属性
在不修改源代码的情况下对程序本身添加之前没有的功能
在运行时对象中添加补丁，而不是在磁盘中的源代码上

17. gevent

18. django 外键的使用
1. django model ForeignKey 字段中可以指定 `db_constraint=False` 那么在使用 Django migration 的时候就不会在数据库中生成外键.
主键和索引是不可少的，不仅可以优化数据检索速度，开发人员还省不其它的工作,

矛盾焦点：数据库设计是否需要外键。这里有两个问题：一个是如何保证数据库数据的完整性和一致性；二是第一条对性能的影响。

正方观点：
由数据库自身保证数据一致性，完整性，更可靠，因为程序很难100％保证数据的完整性，而用外键即使在数据库服务器当机或者出现其他问题的时候，也能够最大限度的保证数据的一致性和完整性。
数据库和应用是一对多的关系，Ａ应用会维护他那部分数据的完整性，系统一变大时，增加了Ｂ应用，Ａ和Ｂ两个应用也许是不同的开发团队来做的。他们如何协调保证数据的完整性，而且一年以后如果又增加了C应用呢？
有主外键的数据库设计可以增加ER图的可读性，这点在数据库设计时非常重要。
外键在一定程度上说明的业务逻辑，会使设计周到具体全面。
反方观点：
可以用触发器或应用程序保证数据的完整性
过分强调或者说使用主键／外键会平添开发难度，导致表过多等问题
不用外键时数据管理简单，操作方便，性能高（导入导出等操作，在insert, update, delete 数据的时候更快）
在海量的数据库中想都不要去想外键，试想，一个程序每天要insert数百万条记录，当存在外键约束的时候，每次要去扫描此记录是否合格，一般还不 止一个字段有外键，这样扫描的数量是成级数的增长！
我的一个程序入库在3个小时做完，如果加上外键，需要28个小时！
表之间互相引用外键造成“死锁”

19. mysql 简单查询


21.keep alvie 什么时候才会有
我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，
完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，
当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

http 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，
如果加入"Connection: close "，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，
所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况

22.HTTP1.0和HTTP1.1的一些区别

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。


23.HTTP2.0和HTTP1.X相比的新特性
新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，
二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。

24.http 和 https的区别
HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。


25.常见的http导致的问题
中间人劫持（公共的wifi  dns劫持  供应商给你网站加广告）

26.HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？

HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；

26.csrf 跨站
CSRF攻击利用网站对于用户网页浏览器的信任，挟持用户当前已登陆的Web应用程序，去执行并非用户本意的操作。


角色：

正常浏览网页的用户：User
正规的但是具有漏洞的网站：WebA
利用CSRF进行攻击的网站：WebB

(1) 用户登录、浏览并信任正规网站WebA，同时，WebA通过用户的验证并在用户的浏览器中产生Cookie。
(2) 攻击者WebB通过在WebA中添加图片链接等方式诱导用户User访问网站WebB。
(3) 在用户User被诱导访问WebB后，WebB会利用用户User的浏览器访问第三方网站WebA，并发出操作请求。
(4) 用户User的浏览器根据WebB的要求，带着步骤一中产生的Cookie访问WebA。
(5) 网站WebA接收到用户浏览器的请求，WebA无法分辨请求由何处发出，由于浏览器访问时带上用户的Cookie，因此WebA会响应浏览器的请求，如此一来，攻击网站WebB就达到了模拟用户操作的目的。

未做 refer限制

27.docker 的好处
Docker可以解决虚拟机能够解决的问题，同时也能够解决虚拟机由于资源要求过高而无法解决的问题。Docker能处理的事情包括：
隔离应用依赖
创建应用镜像并进行复制
创建容易分发的即启即用的应用
允许实例简单、快速地扩展
测试应用并随后销毁它们
28.django 源码